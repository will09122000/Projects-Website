{
    "Personal": {
      "EERC_Bot": {},
      "Website": {}
    },
    "GCSE": {},
    "A_Level": {
      "Rowing_Monitor": {}
    },
    "First_Year": {
        "Countdown_Simulator": {
          "a": "This was my first programming coursework at Univeristy, it is a simulated game of Countdown from a command-line interface.",
          "b": "The user is prompted 9 times to choose either a vowel or a consonant using the letters 'v' and 'c' as inputs. A random letter depending on their input is added to a list using the same probability distribution from the Countdown show.  The 9 letters for this function will be returned as a string.",
          "c": "A list of words is created from 'words.txt' with punctuation removed and words less than 10 letters long. The argument for this function is expected to be the name of a text file as a string. The words will then be returned as a list.",
          "d": "The next function will take the 9 letter string and return two lists. The first being all possible words that can be made from those 9 letters and the second being the longest words that can be made.",
          "e": "The last main function asks the user to input their best guess as well as being given the chance to shuffle the letters. Their input is checked against all possible words to see if there is a match. If there is the program will print out: the number of points scored, statistics on how 'good' their word was, if they scored maximum points and lastly a list of the longest words."

        },
        "Smart_Alarm_Clock": {
            "Main": "This program is a smart alarm clock intended to be run 24/7. It enables the user to schedule, edit and cancel alarms. The user is notified when an alarm is up via an alarm sound, text to speech and a notification which is displayed in the notifications column. The user is also notified when the weather in the location selected has changed and when there is a new news story. The web page will automatically refresh every 5 minutes to keep the notifications, weather and news up to date on screen.",
            "Notifications": "This module is responsible for all notification functionality. It displays the latest notifications in the centre column on the webpage ordered by time. The user can clear the notifications or filter the displayed notifications from three categories: alarms, weather and news.",
            "Alarms": "This module is responsible for all alarm functionality. The user can add new alarms with the two optional options. First, they can select days of the week for the alarm to repeat on. Secondly, an alarm label which is displayed in notifications and read out to the user when the alarm goes off along with an alarm sound. The alarm is also logged when it goes off along with the appropriate data. The user edit the time of a regular alarm or repeating alarm once it's been set and delete alarms.",
            "News": "This module is responsible for all news functionality. It uses newsapi to fetch the latest news stories every 60 seconds",
            "Weather": "This module is responsible for all weather functionality. It uses openweathermap to fetch the current weather in the given location every 30 seconds. This data is then displayed on the main page. A notification is sent each time weather has been fetched and some data has changed, this is also logged. The user can change the location of the weather with the name of a Town or City."
        },
        "Barnabys_Brewhouse": {
          "Main": "This program provides multiple features to make processing beer and decision making easier for Barnaby's Brewhouse. This is achieved through python and basic html/css using the flask libary to display a web interface",
          "Batch_Management": "This module is responsible for handling the creation, movement and termination of batches created from the user interface. It allows the user to upload a new batch of beer with the choice of a tank preference and if not the most suitable tank is automatically picked displaying all batches currently being processed.",
          "Tank_Management": "This module is reponsible for fetching the status of each tank. The status of each tank is then displayed with details of the batch inside each tank.",
          "Inventory": "This module handles fetching the inventory from the json file and updating the inventory when a manual update is requested. The inventory is then displayed for each beer enabling them to update the stock manually in case beers are returned or other unforeseen circumstances.",
          "Order_Management": "This module is responsible for handling customer orders inputted by the user via the user interface. It allowes the user to upload sales data to be used to influence the planning decisions on which beer to brew next with reasoning.",
          "Beer_Suggestion": "This module is responsible for suggesting the type of beer that should be produced. A score for each beer type is accumulated through the module and the highest score is the beer that is suggested next.",
          "Sales_Preditions": "This module is responsible for predicting the demand of each beer type for a month of sales 3 months from the current date. The average growth and sales from the same month in the previous years are used to calculate this prediction."
        },
        "Beanbag_Store": {
          "Main": "This assignment was a pair-programming project based around the development of a back-end Java package. This package was to be used by a client who have determined what they require of the system including an interface. They also already have the front-end developed. This back-end will enable them to: manage stock such as adding beanbags and setting their price; selling beanbags; reserving beanbags for customers and retrieve information such as the total price of the beanbags sold."
        },
        "Task_Manager": {
          "Main": "This coursework was a section of my Web Development module. The main page allows the user to each manage their own tasks. From editing tasks, marking tasks as complete and deleting tasks.",
          "Log_In": "The log in screen requires a username and a password. The username and hashed password with salt and pepper is looked up in a database. Appropriate error messages are displayed to the user when an unsuccessful log in occurs.",
          "Sign_Up": "This page is intended for new users with much of the code similar to that of the log in page. The main differences are checking if the username already exists in the database and checking the two passwords the users has entered match. If it's successful, they are taken to the home page and their details are added to the database.",
          "New_Task": "Here the user can create a new task which includes a title, description and a due date. This task is added to the database and they are returned to the home page with their new task added to the table displayed.",
          "Import_Export_Tasks": "This allowed the user to import and export tasks to and from a shared database of tasks using an API. Imported tasks were then added to the database as if they had created them with the 'New Task' page."
        },
        "Lift_Algorithm": {
          "Main": "The idea of this courework was to design and implement an algorithm for a lift using data structures we had learnt in the module. This algorithm would then be compared against a base algorithm which also had to be implemented. These algorithms dictated where the lift would go in order to serve random requests from one floor to another.",
          "Settings": "The settings page allowed you to configure the total number of floors; the spawn rate of new requests and the speed the lift travelled between floors.",
          "Base_Algorithm": "The design of this base algorithm was provided; however, we still had to implement it into our program. Tthe lift starts from the bottom floor and continually travels to the top floor and back down to the ground floor, picking up requests if they are heading the same direction as the lift and the lift is not full. Each time a floor is reached, those requests inside the lift who's destination is the current floor are removed from the lift.",
          "Improved_Algorithm": "For the improved algorithm, the lift starts from the bottom floor. While there are no requests on any floor or in the lift, the lift will travel to the middle floor and wait there for requests to be in the optimal position pending a new request on a random floor. When a request spawns and the lift is empty, the lift will travel to the request that has been waiting the longest picking up any requests heading in the same direction as the lift. The lift will then travel to the destination floor of that request also picking up any heading in the same direction as the lift."
        }
      },
    "Second_Year": {},
    "Third_Year": {},
    "Fourth_Year": {}
  }