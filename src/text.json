{
    "ALevel": {
      "RowData": {
        "RowData": "This program was my A-Level Computer Science Project. The purpose of it was to replace the dated rowing monitor found on most common indoor rowing machines as seen in the picture below. Navigating these clunky screens was a pain with the limited screen space and inputs. My program improved upon this software in many ways and made for an overall better indoor rowing experience. RowData was made using Python with the use of Pygame for the GUI.",
        "Login": "This is the first screen when the program is run, it allows you to sign in or create a new account. These accounts will store your individual rowing statistics along with personal best times.",
        "Menu": "After a successful log in or sign up, the user is taken to the main menu. From here, they can choose to just row with no goal; start a custom rowing workout; view their statistics; sign out or quit the program.",
        "Justrow": "This is the display that you will see while you are rowing, it displays all the information most people would want in a large font to make it as clear as possible.",
        "Summary": "When the user presses 'Save & Exit', a summary of their row is displayed detailing various averages and totals.",
        "Pb": "If a user selects 'CUSTOM ROW' from the main menu, they are prompted to select a set distance or time. If the user has complete this set distance or time before, their personal best is displayed at the bottom of the screen along with their current row. Enabling them to effectively race against their personal best."
      }
    },
    "Personal": {
      "Discord_Bot": {
        "a": "Discord is a free communication platform that lets you chat in both text and voice calls. It also provides an API allowing you to create Discord server bots. These bots are automated users that perform actions assigned to them by the developer.",
        "b": "This bot provides various commands and features for both admins and users of selected Discord Servers, these Servers are all part of an online sim-racing community known as EERC (European E-Racing Community). It is programmed in JavaScript and runs in Node.js. Below are just a few examples of what this bot is able to do.",
        "Reminders": "Reminders can be set for someone else in the server or yourself, the user is then notified with the message after the pre-determined delay. It is also possible to notify a user at a certain time of day (e.g 14:00).",
        "Weather": "The Weather can play a large part in an online race, it can be advantageous to know the weather beforehand. Therefore, we needed a fair and slightly random way of configuring the weather settings for a race. This command uses the percentage chance of rain during the race along with an element of randomness to output the weather settings for the race, this weather can include: clear skies, light cloud, overcast, light rain and rain.",
        "Stats": "This command displays statistics on the user's activity on all servers with the bot. The first picture shows their average number of messages sent on each day of the week on each server. The second displays their average number of messages sent each hour of the day on each server. Lastly, the third displays the top 10 chat channels the user is active in.",
        "Roles": "Discord Roles enable you to categories and set permissions for users in the server. For example, British users get the British role. These commands below allow the user to assign their own roles rather than an admin assigning it, this is especially useful in larger servers with lots of people wanting various roles.",
        "TTS": "Using Google's text to speech API, this bot will read aloud messages to users in a voice channel. This is used when penalties are announced to those driving during an online endurance race."
      },
      "Website": {}
    },
    "First_Year": {
      "Countdown_Simulator": {
        "a": "This was my first programming coursework at University, it is a simulated game of Countdown from a command-line interface.",
        "b": "The user is prompted 9 times to choose either a vowel or a consonant using the letters 'v' and 'c' as inputs. A random letter depending on their input is added to a list using the same probability distribution from the Countdown show.  The 9 letters for this function will be returned as a string.",
        "c": "A list of words is created from 'words.txt' with punctuation removed and words less than 10 letters long. The argument for this function is expected to be the name of a text file as a string. The words will then be returned as a list.",
        "d": "The next function will take the 9 letter string and return two lists. The first being all possible words that can be made from those 9 letters and the second being the longest words that can be made.",
        "e": "The last main function asks the user to input their best guess as well as being given the chance to shuffle the letters. Their input is checked against all possible words to see if there is a match. If there is the program will print out: the number of points scored, statistics on how 'good' their word was, if they scored maximum points and lastly a list of the longest words.",
        "WDIL": "As this was the first programming coursework, the actual python code and overall logic of the program was relatively simple. However, it did teach me how to format code correctly using a pre-determined style. This included documentation such as comments and doc strings."

      },
      "Smart_Alarm_Clock": {
          "Main": "This program is a smart alarm clock intended to be run 24/7. It enables the user to schedule, edit and cancel alarms. The user is notified when an alarm is up via an alarm sound, text to speech and a notification which is displayed in the notifications column. The user is also notified when the weather in the location selected has changed and when there is a new news story. The web page will automatically refresh every 5 minutes to keep the notifications, weather and news up to date on screen.",
          "Notifications": "This module is responsible for all notification functionality. It displays the latest notifications in the centre column on the webpage ordered by time. The user can clear the notifications or filter the displayed notifications from three categories: alarms, weather and news.",
          "Alarms": "This module is responsible for all alarm functionality. The user can add new alarms with the two optional options. First, they can select days of the week for the alarm to repeat on. Secondly, an alarm label which is displayed in notifications and read out to the user when the alarm goes off along with an alarm sound. The alarm is also logged when it goes off along with the appropriate data. The user edit the time of a regular alarm or repeating alarm once it's been set and delete alarms.",
          "News": "This module is responsible for all news functionality. It uses newsapi to fetch the latest news stories every 60 seconds",
          "Weather": "This module is responsible for all weather functionality. It uses openweathermap to fetch the current weather in the given location every 30 seconds. This data is then displayed on the main page. A notification is sent each time weather has been fetched and some data has changed, this is also logged. The user can change the location of the weather with the name of a Town or City.",
          "WDIL": "This coursework was the first time I had used the Python library 'Flask' (a micro web application framework); This furthered my knowledge in HTTP methods such as GET and POST along with building a simple web layout with HTML and CSS."
      },
      "Barnabys_Brewhouse": {
        "Main": "This program provides multiple features to make processing beer and decision making easier for Barnaby's Brewhouse. This is achieved through python and basic html/css using the flask library to display a web interface",
        "Batch_Management": "This module is responsible for handling the creation, movement and termination of batches created from the user interface. It allows the user to upload a new batch of beer with the choice of a tank preference and if not the most suitable tank is automatically picked displaying all batches currently being processed.",
        "Tank_Management": "This module is responsible for fetching the status of each tank. The status of each tank is then displayed with details of the batch inside each tank.",
        "Inventory": "This module handles fetching the inventory from the json file and updating the inventory when a manual update is requested. The inventory is then displayed for each beer enabling them to update the stock manually in case beers are returned or other unforeseen circumstances.",
        "Order_Management": "This module is responsible for handling customer orders inputted by the user via the user interface. It allows the user to upload sales data to be used to influence the planning decisions on which beer to brew next with reasoning.",
        "Beer_Suggestion": "This module is responsible for suggesting the type of beer that should be produced. A score for each beer type is accumulated through the module and the highest score is the beer that is suggested next.",
        "Sales_Predictions": "This module is responsible for predicting the demand of each beer type for a month of sales 3 months from the current date. The average growth and sales from the same month in the previous years are used to calculate this prediction.",
        "WDIL": "This coursework introduced me to logging actions that occur in your program, this was done using the Python library 'logging'. Although this was required for the coursework, I also found it very useful for debugging certain issues with the program."
      },
      "Beanbag_Store": {
        "Main": "This assignment was a pair-programming project based around the development of a back-end Java package. This package was to be used by a client who have determined what they require of the system including an interface. They also already have the front-end developed. This back-end will enable them to: manage stock such as adding beanbags and setting their price; selling beanbags; reserving beanbags for customers and retrieve information such as the total price of the beanbags sold.",
        "WDIL": "This was the first project I had done in Java. During development, I felt I improved my understanding of Object Orientated Programming as a whole as well as Java semantics."
      },
      "Task_Manager": {
        "Main": "This coursework was a section of my Web Development module. The main page allows the user to each manage their own tasks. From editing tasks, marking tasks as complete and deleting tasks.",
        "Log_In": "The log in screen requires a username and a password. The username and hashed password with salt and pepper is looked up in a database. Appropriate error messages are displayed to the user when an unsuccessful log in occurs.",
        "Sign_Up": "This page is intended for new users with much of the code similar to that of the log in page. The main differences are checking if the username already exists in the database and checking the two passwords the users has entered match. If it's successful, they are taken to the home page and their details are added to the database.",
        "New_Task": "Here the user can create a new task which includes a title, description and a due date. This task is added to the database and they are returned to the home page with their new task added to the table displayed.",
        "Import_Export_Tasks": "This allowed the user to import and export tasks to and from a shared database of tasks using an API. Imported tasks were then added to the database as if they had created them with the 'New Task' page.",
        "WDIL": "This coursework improved my knowledge of basic web design and styling; the use of a database alongside a website and the use of SOAP APIs. This was also my first (and hopefully last) time using PHP to create a website."
      },
      "Lift_Algorithm": {
        "Main": "The idea of this coursework was to design and implement an algorithm for a lift using data structures we had learnt in the module. This algorithm would then be compared against a base algorithm which also had to be implemented. These algorithms dictated where the lift would go in order to serve random requests from one floor to another.",
        "Settings": "The settings page allowed you to configure the total number of floors; the spawn rate of new requests and the speed the lift travelled between floors.",
        "Base_Algorithm": "The design of this base algorithm was provided; however, we still had to implement it into our program. The lift starts from the bottom floor and continually travels to the top floor and back down to the ground floor, picking up requests if they are heading the same direction as the lift and the lift is not full. Each time a floor is reached, those requests inside the lift who's destination is the current floor are removed from the lift.",
        "Improved_Algorithm": "For the improved algorithm, the lift starts from the bottom floor. While there are no requests on any floor or in the lift, the lift will travel to the middle floor and wait there for requests to be in the optimal position pending a new request on a random floor. When a request spawns and the lift is empty, the lift will travel to the request that has been waiting the longest picking up any requests heading in the same direction as the lift. The lift will then travel to the destination floor of that request also picking up any heading in the same direction as the lift.",
        "WDIL": "This coursework was the first time I had to implement threading into a project and ended up being relatively simple in Python. This allowed for the creation of people requesting to use the lift to process on a separate thread."
      }
    },
    "Second_Year": {
      "Card_Game": {
        "Main": "This coursework was a pair-programming exercise. We developed in Java, a multi-threaded card playing simulation. Within the design we implemented a thread-safe Card class, Card Deck, and a Player class. The program then runs from the executable CardGame class.",
        "Card_Class": "",
        "Card_Deck_Class": "",
        "Player_Class": "",
        "WDIL": ""
      },
      "Functional_Programming": {
        "Question_1_1": "The aim of the first question was to create a haskell program that could validate answers and find all solutions to the following puzzle. A puzzle requires one to find six-digit numbers where:",
        "Question_1_2": "1. all digits are different;",
        "Question_1_3": "2. alternate digits are even and odd, or odd and even;",
        "Question_1_4": "3. alternate digits differ by more than two;",
        "Question_1_5": "4. the first and middle pairs of digits form numbers that are both multiples of the last.",
        "Question_2_1": "The second question was based on the 'Game of Life'. The late John Conway was a mathematician who became known outside the world of mathematics for his invention of the Game of Life. The game involves configuring a cellular automaton and then observing how it evolves according to three rules. The cells are organised as a two-dimensional grid, and are either live or dead. The three rules of evolution are:",
        "Question_2_2": "1. Any live cell with two or three live neighbours survives.",
        "Question_2_3": "2. Any dead cell with three live neighbours becomes alive.",
        "Question_2_4": "3. All other live cells die, and all other dead cells stay dead",
        "Question_2_5": "The next generation is created by applying the rules simultaneously to every cell in the current generation, so that births and deaths occur simultaneously.",
        "WDIL": ""
      },
      "Logical_Programming": {
        "Question_1": "",
        "Question_2": "",
        "WDIL": ""
      },
      "Group_Software_Engineering_Project": {},
      "Puzzle_Problem": {
        "Main": "The aim of the 8-puzzle is to reach a predefined configuration of tiles from another configuration of tiles. The 8-puzzle problem can be seen as a search problem due to its following attributes. First, the puzzle has discrete states, these different states are dependent on the position of each tile in the puzzle. One tile is missing enabling a tile next to it to move into that position. The puzzle has four operators, the missing tile can either move up, down, left, or down. Also, the puzzle has an end goal, this goal can any one of the possible states the puzzle can be in. In this question, the goal state is to have the missing tile in the top right with the rest of the tiles in ascending order. Lastly, a search problem requires a path cost. In this puzzle, the path cost is equal to one each time a tile is moved into the missing tile space.",
        "Manhattan": "The first heuristic function I have picked is the sum of ‘Manhattan’ distances each tile is away from its goal position. So the closer the tiles are to their goal position, the smaller the heuristic value gets. It’s called the ‘Manhattan’ distance because it’s the number of rows plus the number of columns away from the target rather than a direct distance as the crow flies. I chose this type of distance because it is a better representation of how tiles move in the puzzle and therefore should be a better heuristic.",
        "Euclidean": "The second heuristic function I have picked is the sum of ‘Euclidean’ distances each tile is away from its goal position. This is similar to the first heuristic but instead the distances are defined as a direct distance as the crow flies. I predict that this heuristic will not perform as well as the first once. I chose this heuristic because I wanted to see if I was correct and if so, how big the solving time is between these two heuristics.",
        "WDIL": ""
      },
      "Post_Office_Queue": {},
      "Vaccine_Ordering": {}
    },
    "Third_Year": {}
  }